#include <iostream>
static void help(const char *argv0, std::ostream &o)
{
  o
    << "use: " << argv0 << " CONFIG.info\n"
    << "     " << argv0 << " CONFIG.json\n"
       "\n\n"
       "config.info example:\n"
       "  union {\n"
       "    std::string\n"
       "    int64_t\n"
       "  }\n"
       "  ; comment\n"
       "  option {\n"
       "    ; options are optional\n"
       "    name Class_Name\n"
       "    namespace {\n"
       "      First_Level\n"
       "      Second_Level\n"
       "    }\n"
       "    ; more options are available\n"
       "  }\n\n"
       "Command Line Options:\n"
       "  -h, --help                      This screen\n"
       "  -o FILENAME, --output FILENAME  Filename of the implementation file\n"
       "  --header FILENAME               Filename of the header file\n"
       "  --ext EXT                       Default extension for implementation files\n"
       "  --hext EXT                      Default extension for header files\n"
       "\n\n"
       "2015-05-30, Georg Sauthoff <mail@georg.so>\n";
}

// Copyright 2015, Georg Sauthoff <mail@georg.so>

/* {{{ GPLv3

    This file is part of the variant generator.

    $PROGRAM is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    $PROGRAM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with $PROGRAM.  If not, see <http://www.gnu.org/licenses/>.

}}} */

#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/property_tree/info_parser.hpp>
#include <boost/regex.hpp>
#include <boost/filesystem.hpp>

#include <set>
#include <string>
#include <deque>
#include <vector>
#include <fstream>
#include <string.h>
#include <stdlib.h>
#include <cctype>

using namespace std;
namespace bf = boost::filesystem;

enum class Input {
  AUTO,
  INFO,
  JSON
};
struct Options {
  int argc;
  char **argv;

  Input input { Input::AUTO };
  string input_filename;
  string implementation_filename;
  string header_filename;
  string ext {"cc"};
  string hext {"hh"};

  Options(int argc, char **argv);

  void write_comment(ostream &out);

  private:
    void detect_input();
    void derive_filenames();
};

Options::Options(int argc, char **argv)
  :
    argc(argc),
    argv(argv)
{
  vector<char *> positional;
  for (int i = 1; i<argc; ++i) {
    if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
      help(argv[0], cout);
      exit(0);
    } else if (!strcmp(argv[i], "--output") || !strcmp(argv[i], "-o")) {
      ++i;
      if (i>=argc)
        throw underflow_error("no argument to the --output option");
      implementation_filename = argv[i];
    } else if (!strcmp(argv[i], "--header")) {
      ++i;
      if (i>=argc)
        throw underflow_error("no argument to the --header option");
      implementation_filename = argv[i];
    } else if (!strcmp(argv[i], "--hext")) {
      ++i;
      if (i>=argc)
        throw underflow_error("no argument to the --hext option");
      hext = argv[i];
    } else if (!strcmp(argv[i], "--ext")) {
      ++i;
      if (i>=argc)
        throw underflow_error("no argument to the --ext option");
      ext = argv[i];
    } else {
      positional.push_back(argv[i]);
    }
  }
  if (positional.empty())
    throw runtime_error("no filename specified");
  if (positional.size() > 1)
    throw runtime_error("too many positional arguments");
  input_filename = positional.front();
  detect_input();
  derive_filenames();
}

void Options::write_comment(ostream &o)
{
  o << "/**************************************************************************/\n"
       "/*\n"
       "   Autogenerated by the Variant Generator.\n\n"
       "   Call was:\n\n"
       "     ";
  if (argc)
    o << '\'' << *argv << '\'';
  for (int i = 1; i < argc; ++i)
    o << " '" << argv[i] << '\'';
  o << "\n"
       "                                                                          */\n"
       "/**************************************************************************/\n";
}
void Options::detect_input()
{
  if (input == Input::AUTO) {
    if (boost::iends_with(input_filename, ".inf"))
      input = Input::INFO;
    else if (boost::iends_with(input_filename, ".json"))
      input = Input::JSON;
    else
      input = Input::INFO;
  }
}
void Options::derive_filenames()
{
  if (implementation_filename.empty()) {
    bf::path p(input_filename);
    p.replace_extension(ext);
    implementation_filename = p.generic_string();
  }
  if (header_filename.empty()) {
    bf::path p(implementation_filename);
    p.replace_extension(hext);
    header_filename = p.generic_string();
  }
}

namespace KEY {
  static const char UNION[] = "union";
  static const char OPTION[] = "option";
  static const char GUARD[] = "guard";
  static const char NAME[] = "name";
  static const char DEFAULT_CONSTRUCTOR[] = "default_constructor";
  static const char MOVE[] = "move";
  static const char COPY[] = "copy";
  static const char VALUE_MOVE[] = "value_move";
  static const char VALUE_COPY[] = "value_copy";
  static const char HEADER_FILENAME[] = "header_filename";
  static const char NAMESPACE[] = "namespace";
  static const char INCLUDE[] = "include";
  static const char DESTRUCTOR[] = "destructor";
}

static string mk_name(const string &x)
{
  static const boost::regex re("[ :*<>,]+");
  string s(boost::regex_replace(x, re, "_"));
  boost::to_lower(s);
  s += "_";
  return s;
}
static bool is_elementary(const string &s)
{
  static const set<string> types = {
    "bool",
    "char",
    "unsigned char",
    "int",
    "unsigned",
    "long",
    "long int",
    "long long",
    "long long int",
    "unsigned long",
    "unsigned long int",
    "unsigned long long",
    "unsigned long long int",
    "short",
    "short int",
    "unsigned short",
    "unsigned short int",
    "int8_t",
    "uint8_t",
    "int16_t",
    "uint16_t",
    "int32_t",
    "uint32_t",
    "int64_t",
    "uint64_t",
    "double",
    "float"
  };
  return types.count(s);
}

class Base {
  private:
  protected:
    const boost::property_tree::ptree &union_;
    const boost::property_tree::ptree &opt_;
    ostream &o;

    void write_namespace_open();
    void write_namespace_close();
  public:
    Base(const boost::property_tree::ptree &uni,
        const boost::property_tree::ptree &opt,
        ostream &o);
    virtual ~Base();
};
Base::Base(const boost::property_tree::ptree &uni,
    const boost::property_tree::ptree &opt,
    ostream &o)
  :
    union_(uni),
    opt_(opt),
    o(o)
{
}
Base::~Base()
{
}
void Base::write_namespace_open()
{
  if (opt_.find(KEY::NAMESPACE) == opt_.not_found())
    return;
  auto &ns = opt_.get_child(KEY::NAMESPACE);
  for (auto &n : ns)
    o << "namespace " << n.first << " {\n";
  o << '\n';
}
void Base::write_namespace_close()
{
  if (opt_.find(KEY::NAMESPACE) == opt_.not_found())
    return;
  auto &ns = opt_.get_child(KEY::NAMESPACE);
  for (auto &n : ns)
    o << "} // " << n.first << '\n';
  o << '\n';
}

class Header : public Base {
  private:
    bool need_stdint();
    bool need_string();
    bool need_utility();
    void write_includes();
    void write_private();
    void write_public();
    void write_value_move_constructor();
    void write_value_move_assignment();
    void write_value_copy_constructor();
    void write_value_copy_assignment();
    void write_apply(const string &method_name,
        bool visitor_is_const, bool member_is_const);
  public:
    using Base::Base;

    void write();
};
void Header::write()
{
  o << "#ifndef " << opt_.get<string>(KEY::GUARD) << '\n'
     << "#define " << opt_.get<string>(KEY::GUARD) << "\n\n";

  write_includes();
  write_namespace_open();

  o << "class " << opt_.get<string>(KEY::NAME) << " {\n";

  o << "  private:\n";
  write_private();
  o << "  public:\n";
  write_public();
  o << "};\n\n";

  write_namespace_close();

  o << "\n\n#endif\n";
}
bool Header::need_stdint()
{
  static const set<string> stdints = {
    "uint8_t",
    "int8_t",
    "uint16_t",
    "int16_t",
    "uint32_t",
    "int32_t",
    "uint64_t",
    "int64_t"
  };
  for (auto &i : stdints)
    if (union_.count(i))
      return true;
  return false;
}
bool Header::need_string()
{
  return union_.count("std::string");
}
bool Header::need_utility()
{
  for (auto &x : union_)
    if (boost::starts_with(x.first, "std::pair<"))
      return true;
  return false;
}
void Header::write_includes()
{
  o << "#include <stdexcept>\n";
  if (need_stdint())
    o << "#include <stdint.h>\n";
  if (need_string())
    o << "#include <string>\n";
  if (need_utility())
    o << "#include <utility>\n";
  o << '\n';

  if (opt_.find(KEY::INCLUDE) == opt_.not_found())
    return;
  auto &is = opt_.get_child(KEY::INCLUDE);
  for (auto &i : is)
    if (!i.first.empty() && (i.first[0] == '"' || i.first[0] == '<'))
      o << "#include " << i.first << '\n';
    else
      o << "#include <" << i.first << ">\n";

  o << '\n';
}
void Header::write_private()
{
  o << "    uint8_t tag_ {0};\n";
  o << "    union {\n";
  for (auto &x : union_) {
    o << "      " << x.first << ' ' << mk_name(x.first) << ";\n";
  }
  o << "    };\n";
  o << "    void destruct();\n";
}
void Header::write_public()
{
  string n(opt_.get<string>(KEY::NAME));
  if (opt_.get<bool>(KEY::DEFAULT_CONSTRUCTOR))
    o << "    " << n << "();\n";
  o << "    " << n << "(" << n << " &&o)";
  if (!opt_.get<bool>(KEY::MOVE))
    o << " =delete";
  o << ";\n";
  o << "    " << n << "(const " << n << " &o)";
  if (!opt_.get<bool>(KEY::COPY))
    o << " =delete";
  o << ";\n";
  write_value_move_constructor();
  write_value_copy_constructor();
  o << "    ~" << n << "();\n";
  o << "\n";
  o << "    " << n << " &" << "operator=(" << n << " &&o)";
  if (!opt_.get<bool>(KEY::MOVE))
    o << " =delete";
  o << ";\n";
  o << "    " << n << " &" << "operator=(const " << n << " &o)";
  if (!opt_.get<bool>(KEY::COPY))
    o << " =delete";
  o << ";\n";
  write_value_move_assignment();
  write_value_copy_assignment();
  write_apply("apply", false, false);
  write_apply("apply", true, false);
  write_apply("accept", false, true);
  write_apply("accept", true, true);
}
void Header::write_value_move_constructor()
{
  if (!opt_.get<bool>(KEY::VALUE_MOVE))
    return;
  bool value_copy = opt_.get<bool>(KEY::VALUE_COPY);
  string n(opt_.get<string>(KEY::NAME));

  unsigned i = 1;
  for (auto &x : union_) {
    if (is_elementary(x.first) && value_copy) {
      ++i;
      continue;
    }
    o << "    " << n << '(' << x.first << ' ';
    if (!(is_elementary(x.first)))
      o << "&&";
    o << "o);\n";
    ++i;
  }
}
void Header::write_value_move_assignment()
{
  if (!opt_.get<bool>(KEY::VALUE_MOVE))
    return;
  bool value_copy = opt_.get<bool>(KEY::VALUE_COPY);
  string n(opt_.get<string>(KEY::NAME));

  unsigned i = 1;
  for (auto &x : union_) {
    if (is_elementary(x.first) && value_copy) {
      ++i;
      continue;
    }
    o << "    " << n << " &" << "operator=(" << x.first << ' ';
    if (!(is_elementary(x.first)))
      o << "&&";
    o << "o);\n";
    ++i;
  }
}
void Header::write_value_copy_constructor()
{
  if (!opt_.get<bool>(KEY::VALUE_COPY))
    return;
  string n(opt_.get<string>(KEY::NAME));

  unsigned i = 1;
  for (auto &x : union_) {
    o << "    " << n << '(';
    if (is_elementary(x.first))
      o << x.first << " o);\n";
    else
      o << "const " << x.first << " &o);\n";
    ++i;
  }
}
void Header::write_value_copy_assignment()
{
  if (!opt_.get<bool>(KEY::VALUE_COPY))
    return;
  string n(opt_.get<string>(KEY::NAME));

  unsigned i = 1;
  for (auto &x : union_) {
    o << "    " << n << " &" << "operator=(";
   
    if (is_elementary(x.first))
      o << x.first << " o);\n";
    else
      o << "const " << x.first << " &o);\n";
    ++i;
  }
}

void Header::write_apply(const string &method_name,
    bool visitor_is_const, bool member_is_const)
{
  o << "    template <typename T> typename T::result_type " << method_name
    << "("
     << (visitor_is_const ? "const " : "") << "T &t)"
     << (member_is_const ? " const" : "") << "\n"
        "    {\n"
        "      switch (tag_) {\n";
  unsigned i = 1;
  for (auto &x : union_) {
    string name(mk_name(x.first));
    o << "        case " << i << " : return t(" << name << ");\n";
    ++i;
  }
  o << "      }\n"
        "      throw std::domain_error(\"variant not initialized\");\n"
        "    }\n\n";
}

class Implementation : public Base {
  private:
    void write_default_constructor();
    void write_move_constructor();
    void write_copy_constructor();
    void write_destructor();
    void write_destruct();
    void write_move_assignment();
    void write_copy_assignment();
    void write_value_move_constructor();
    void write_value_move_assignment();
    void write_value_copy_constructor();
    void write_value_copy_assignment();
    string mk_naked_name(const string &x);
  public:
    using Base::Base;

    void write();
};
string Implementation::mk_naked_name(const string &x)
{
  string s(x);
  auto d = opt_.find(KEY::DESTRUCTOR);
  if (d != opt_.not_found()) {
    auto &ms = d->second;
    auto i = ms.find(x);
    if (i != ms.not_found())
      s = i->second.get_value<string>();
  }
  static const boost::regex re("^.*::");
  s = boost::regex_replace(s, re, "");
  return s;
}

void Implementation::write()
{
  o << "#include \"" << opt_.get<string>(KEY::HEADER_FILENAME) << "\"\n\n\n";

  write_namespace_open();

  write_default_constructor();
  write_move_constructor();
  write_copy_constructor();
  write_destructor();
  write_destruct();
  write_move_assignment();
  write_copy_assignment();
  write_value_move_constructor();
  write_value_move_assignment();
  write_value_copy_constructor();
  write_value_copy_assignment();

  write_namespace_close();
}
void Implementation::write_default_constructor()
{
  if (!opt_.get<bool>(KEY::DEFAULT_CONSTRUCTOR))
    return;
  string n(opt_.get<string>(KEY::NAME));
  o << n << "::" << n << "()\n"
     "{\n"
     "}\n\n";
}
void Implementation::write_move_constructor()
{
  if (!opt_.get<bool>(KEY::MOVE))
    return;
  string n(opt_.get<string>(KEY::NAME));
  o << n << "::" << n << "(" << n << " &&o)\n"
        "{\n"
        "  switch(o.tag_) {\n";
  unsigned i = 1;
  for (auto &x : union_) {
    string name(mk_name(x.first));
    o << "    case " << i << ":\n";
    if (is_elementary(x.first))
      o << "      " << name << " = o." << name << ";\n";
    else
      o << "      new (&" << name << ") " << x.first << "(std::move(o." << name << "));\n";
    o << "      tag_ = " << i << ";\n"
          "      break;\n";
    ++i;
  }
  o << "  }\n";
  o << "\n}\n\n";
}
void Implementation::write_move_assignment()
{
  if (!opt_.get<bool>(KEY::MOVE))
    return;
  string n(opt_.get<string>(KEY::NAME));
  o << n << " &" << n << "::operator=(" << n << " &&o)\n{\n"
    "  switch(o.tag_) {\n";
  unsigned i = 1;
  for (auto &x : union_) {
    string name(mk_name(x.first));
    o << "    case " << i << ":\n"
         "      if (tag_ == o.tag_) {\n";
    if (is_elementary(x.first)) {
      o << "        " << name << " = o." << name << ";\n";
    } else {
      o << "        " << name << " = std::move(o." << name << ");\n";
    }
    o << "      } else {\n";
    o << "        destruct();\n";
    if (is_elementary(x.first)) {
      o << "        " << name << " = o." << name << ";\n";
    } else {
      o << "        new (&" << name << ") " << x.first << "(std::move(o." << name << "));\n";
    }
    o << "        tag_ = " << i << ";\n";
    o << "      }\n";
    o << "      break;\n";
    ++i;
  }
  o << "  }\n"
        "  return *this;\n"
        "}\n\n";
}
void Implementation::write_copy_constructor()
{
  if (!opt_.get<bool>(KEY::COPY))
    return;
  string n(opt_.get<string>(KEY::NAME));
  o << n << "::" << n << "(const " << n << " &o)\n"
        "{\n"
        "  switch(o.tag_) {\n";
  unsigned i = 1;
  for (auto &x : union_) {
    string name(mk_name(x.first));
    o << "    case " << i << ":\n";
    if (is_elementary(x.first))
      o << "      " << name << " = o." << name << ";\n";
    else
      o << "      new (&" << name << ") " << x.first << "(o." << name << ");\n";
    o << "      tag_ = " << i << ";\n"
          "      break;\n";
    ++i;
  }
  o << "  }\n";
  o << "\n}\n\n";
}
void Implementation::write_copy_assignment()
{
  if (!opt_.get<bool>(KEY::COPY))
    return;
  string n(opt_.get<string>(KEY::NAME));
  o << n << " &" << n << "::operator=(const " << n << " &o)\n{\n"
    "  switch(o.tag_) {\n";
  unsigned i = 1;
  for (auto &x : union_) {
    string name(mk_name(x.first));
    o << "    case " << i << ":\n"
         "      if (tag_ == o.tag_) {\n";
    o << "        " << name << " = o." << name << ";\n";
    o << "      } else {\n";
    o << "        destruct();\n";
    if (is_elementary(x.first)) {
      o << "        " << name << " = o." << name << ";\n";
    } else {
      o << "        new (&" << name << ") " << x.first << "(o." << name << ");\n";
    }
    o << "        tag_ = " << i << ";\n";
    o << "      }\n";
    o << "      break;\n";
    ++i;
  }
  o << "  }\n"
        "  return *this;\n"
        "}\n\n";
}

void Implementation::write_value_move_constructor()
{
  if (!opt_.get<bool>(KEY::VALUE_MOVE))
    return;
  bool value_copy = opt_.get<bool>(KEY::VALUE_COPY);
  string n(opt_.get<string>(KEY::NAME));

  unsigned i = 1;
  for (auto &x : union_) {
    if (is_elementary(x.first) && value_copy) {
      ++i;
      continue;
    }
    o << n << "::" << n << '(' << x.first << ' ';
    if (!(is_elementary(x.first)))
      o << "&&";
    o << "o)\n";
    string name(mk_name(x.first));
    o << "  : " << name << '(';
    if (!is_elementary(x.first))
      o << "std::move(";
    o << 'o';
    if (!is_elementary(x.first))
      o << ')';
    o << ")\n";
    o << "{\n";
    o << "  tag_ = " << i << ";\n";
    o << "}\n\n";
    ++i;
  }
}

void Implementation::write_value_move_assignment()
{
  if (!opt_.get<bool>(KEY::VALUE_MOVE))
    return;
  bool value_copy = opt_.get<bool>(KEY::VALUE_COPY);
  string n(opt_.get<string>(KEY::NAME));

  unsigned i = 1;
  for (auto &x : union_) {
    if (is_elementary(x.first) && value_copy) {
      ++i;
      continue;
    }
    o << n << " &" << n << "::operator=(" << x.first << ' ';
    if (!(is_elementary(x.first)))
      o << "&&";
    o << "o)\n";
    string name(mk_name(x.first));
    o << "{\n"
          "  if (tag_ == " << i << ") {\n";
    o << "    " << name << " = ";
    if (is_elementary(x.first))
      o << 'o';
    else
      o << "std::move(o)";
    o << ";\n";
    o << "  } else {\n"
          "    destruct();\n";
    if (is_elementary(x.first))
      o << "    " << name << " = o;\n";
    else
      o << "    new (&" << name << ") " << x.first << "(std::move(o));\n";
    o << "    tag_ = " << i << ";\n";
    o << "  }\n"
          "  return *this;\n"
          "}\n\n";
    ++i;
  }
}

void Implementation::write_value_copy_constructor()
{
  if (!opt_.get<bool>(KEY::VALUE_COPY))
    return;
  string n(opt_.get<string>(KEY::NAME));

  unsigned i = 1;
  for (auto &x : union_) {
    o << n << "::" << n << '(';
   
    if (is_elementary(x.first))
      o << x.first << " o)\n";
    else
      o << "const " << x.first << " &o)\n";
    string name(mk_name(x.first));
    o << "  : " << name << "(o)\n";
    o << "{\n";
    o << "  tag_ = " << i << ";\n";
    o << "}\n\n";
    ++i;
  }
}

void Implementation::write_value_copy_assignment()
{
  if (!opt_.get<bool>(KEY::VALUE_COPY))
    return;
  string n(opt_.get<string>(KEY::NAME));

  unsigned i = 1;
  for (auto &x : union_) {
    o << n << " &" << n << "::operator=(";
   
    if (is_elementary(x.first))
      o << x.first << " o)\n";
    else
      o << "const " << x.first << " &o)\n";
    string name(mk_name(x.first));
    o << "{\n"
          "  if (tag_ == " << i << ") {\n";
    o << "    " << name << " = o;\n";
    o << "  } else {\n"
          "    destruct();\n";
    if (is_elementary(x.first))
      o << "    " << name << " = o;\n";
    else
      o << "    new (&" << name << ") " << x.first << "(o);\n";
    o << "    tag_ = " << i << ";\n";
    o << "  }\n"
          "  return *this;\n"
          "}\n\n";
    ++i;
  }
}

void Implementation::write_destructor()
{
  string n(opt_.get<string>(KEY::NAME));
  o << n << "::~" << n << "()\n{\n"
    "  destruct();\n"
    "}\n\n";
}
void Implementation::write_destruct()
{
  o << "void " << opt_.get<string>(KEY::NAME) << "::destruct()\n{\n"
        "  switch(tag_) {\n";
  unsigned i = 1;
  if (union_.size() > 255)
    throw runtime_error("Union may only have 255 members");
  for (auto &x : union_) {
    if (!is_elementary(x.first)) {
      o << "    case " << i << ": " << mk_name(x.first)
         << ".~" << mk_naked_name(x.first) << "(); break;\n";
    }
    ++i;
  }
  o << "  }\n"
        "  tag_ = 0;\n"
        "}\n\n";
}

void empty_string_2_string_empty(boost::property_tree::ptree &us)
{
  deque<string> v;
  for (auto &u : us)
    v.push_back(u.second.get_value<string>());
  us.erase(us.begin(), us.end());
  for (auto &s : v)
    us.put_child(s, boost::property_tree::ptree());
}

static void fix_json(const Options &opts,
    boost::property_tree::ptree &config)
{
  if (opts.input != Input::JSON)
    return;

  if (config.count(KEY::UNION))
    empty_string_2_string_empty(config.get_child(KEY::UNION));

  if (config.count(KEY::OPTION)) {
    auto &option = config.get_child(KEY::OPTION);
    const array<const char*, 2> as = {
      KEY::NAMESPACE,
      KEY::OPTION
    };
    for (auto &a: as)
      if (option.count(a))
        empty_string_2_string_empty(option.get_child(a));
  }
}

static void set_defaults(const Options &opts,
    boost::property_tree::ptree &config)
{
  if (!config.count(KEY::OPTION))
    config.put_child(KEY::OPTION, boost::property_tree::ptree());
  auto &opt = config.get_child(KEY::OPTION);
  bf::path p(opts.input_filename);
  string stem(p.stem().generic_string());
  if (stem.empty())
    throw logic_error("Filename stem is empty");
  if (!opt.count(KEY::NAME)) {
    string s(boost::to_lower_copy(stem));
    s[0] = toupper(s[0]);
    opt.put(KEY::NAME, s);
  }
  if (!opt.count(KEY::GUARD)) {
    string s(boost::to_upper_copy(stem));
    s += "_HH";
    opt.put(KEY::GUARD, s);
  }
  if (!opt.count(KEY::DEFAULT_CONSTRUCTOR))
    opt.put(KEY::DEFAULT_CONSTRUCTOR, true);
  if (!opt.count(KEY::MOVE))
    opt.put(KEY::MOVE, true);
  if (!opt.count(KEY::COPY))
    opt.put(KEY::COPY, false);
  if (!opt.count(KEY::VALUE_MOVE))
    opt.put(KEY::VALUE_MOVE, true);
  if (!opt.count(KEY::VALUE_COPY))
    opt.put(KEY::VALUE_COPY, false);

  if (!opt.count(KEY::HEADER_FILENAME))
    opt.put(KEY::HEADER_FILENAME,
      bf::path(opts.header_filename).filename().generic_string());

  if (!opt.count(KEY::DESTRUCTOR))
    opt.put_child(KEY::DESTRUCTOR, boost::property_tree::ptree());
  auto &destructor = opt.get_child(KEY::DESTRUCTOR);
  if (!destructor.count("std::string"))
    destructor.put("std::string", "basic_string");
}

int main(int argc, char **argv)
{
  try {
    Options opts(argc, argv);
    boost::property_tree::ptree config;
    switch (opts.input) {
      case Input::INFO:
        boost::property_tree::info_parser::read_info(opts.input_filename, config);
        break;
      case Input::JSON:
        boost::property_tree::json_parser::read_json(opts.input_filename, config);
        break;
      case Input::AUTO:
        break;
    }
    fix_json(opts, config);
    set_defaults(opts, config);
    ofstream hs;
    hs.exceptions(ofstream::failbit | ofstream::badbit);
    hs.open(opts.header_filename);
    ofstream impls;
    impls.exceptions(ofstream::failbit | ofstream::badbit);
    impls.open(opts.implementation_filename);
    Header h(config.get_child(KEY::UNION), config.get_child(KEY::OPTION), hs);
    opts.write_comment(hs);
    h.write();
    Implementation impl(config.get_child(KEY::UNION), config.get_child(KEY::OPTION), impls);
    opts.write_comment(impls);
    impl.write();

  } catch (const exception &e) {
    cerr  << "Error: " << e.what() << '\n';
    return 1;
  }
  return 0;
}

